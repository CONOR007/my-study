# 手写promise

> 手写promise首先需要掌握promise的基本用法,然后根据用法去思考实现原理

### 1.promise的核心用法及实现

- 1.promse就是一个类 在执行这个类的时候 需要传递一个执行器 执行器立即执行

  ```
  class MyPromise {
      //1.promse就是一个类 在执行这个类的时候 需要传递一个执行器 执行器立即执行
      constructor (executor) {   
          //executor:立即执行的执行器,它的两个回调函数分别是resolve,reject
          executor(this.resolve,this.reject);
      }
      
      resolve = (value) => {}
      
      reject = (errInfo) => {}
  }
  module.exports = MyPromise
  ```

  

- 2.promse有三种状态,等待:pending 成功:rejected 失败fulfilled  一旦状态确认就不可更改

  ```
  //2.promse有三种状态,等待:pending 成功:rejected 失败fulfilled
  //把状态定义成常量的好处是:1.复用性 2.编辑器会有提示,而字符串是没有提示的
  const PENDING = 'pending';      //等待
  const FULFILLED = 'fulfilled';  //成功
  const REJECTED = 'rejected';    //失败
  
  class MyPromise {
      constructor (executor) {   
          //executor:立即执行的执行器,它的两个回调函数分别是resolve,reject
          executor(this.resolve,this.reject);
      }
  
      //resolve和reject之所以定义成箭头函数就是为了让其内部this指向MyPromise
      resolve = () => {
          //一旦状态确认就不可更改
          if(this.status !== PENDING) return;
      }
  
      reject = () => {
          //一旦状态确认就不可更改
          if(this.status !== PENDING) return;
      }
  }
  
  module.exports = MyPromise
  ```

  

- 3.resolve和reject分别改变状态为成功和失败 调用resolve是pending->fulfilled  调用reject是pending->rejected

  ```
  const PENDING = 'pending';      //等待
  const FULFILLED = 'fulfilled';  //成功
  const REJECTED = 'rejected';    //失败
  
  class MyPromise {
      constructor (executor) {   
          executor(this.resolve,this.reject);
      }
  
      //状态
      status = PENDING;
      //成功值
      value = undefined;
      //失败原因
      errInfo = undefined;     
  
      //3.resolve和reject分别改变状态为成功和失败 调用resolve是pending->fulfilled  调用reject是pending->rejected
      resolve = () => {
          //一旦状态确认就不可更改
          if(this.status !== PENDING) return;
          //将状态更改为成功
          this.status = FULFILLED;
      }
  
      reject = () => {
          //一旦状态确认就不可更改
          if(this.status !== PENDING) return;
          //将状态更改为失败
          this.status = REJECTED;
      }
      
  }
  
  module.exports = MyPromise
  ```

  

- 4.then方法内部做的事情就是判断状态,如果状态成功调用成功的回调 如果状态是失败则调用失败的回调函数

- 5.成功回调参数:value 失败回调参数:errInfo

  ```
  //2.promse有三种状态,等待:pending 成功:rejected 失败fulfilled
  //把状态定义成常量的好处是:1.复用性 2.编辑器会有提示,而字符串是没有提示的
  const PENDING = 'pending';      //等待
  const FULFILLED = 'fulfilled';  //成功
  const REJECTED = 'rejected';    //失败
  
  class MyPromise {
      //1.promse就是一个类 在执行这个类的时候 需要传递一个执行器 执行器立即执行
      constructor (executor) {   
          //executor:立即执行的执行器,它的两个回调函数分别是resolve,reject
          executor(this.resolve,this.reject);
      }
  
      //状态
      status = PENDING;
      //成功值
      value = undefined;
      //失败原因
      errInfo = undefined;     
  
      //3.resolve和reject分别改变状态为成功和失败 调用resolve是pending->fulfilled  调用reject是pending->rejected
      //resolve和reject之所以定义成箭头函数就是为了让其内部this指向MyPromise
      resolve = (value) => {
          //一旦状态确认就不可更改
          if(this.status !== PENDING) return;
          //将状态更改为成功
          this.status = FULFILLED;
          //保存成功之后的值
          this.value = value;
      }
  
      reject = (errInfo) => {
          //一旦状态确认就不可更改
          if(this.status !== PENDING) return;
          //将状态更改为失败
          this.status = REJECTED;
          //保存失败之后的值
          this.errInfo = errInfo;
      }
      
      then (successCallback,failCallback) {
          //4.then方法内部做的事情就是判断状态,如果状态成功调用成功的回调 如果状态是失败则调用失败的回调函数
          //5.成功回调参数:this.value 失败回调参数:errInfo
          if(this.status === FULFILLED) successCallback(this.value);
          if(this.status === REJECTED) failCallback(this.errInfo);
      }
  }
  
  module.exports = MyPromise
  ```

- 代码片段测试,打印 '成功'.

  ```
  new MyPromise((resolve,reject)=>{
      resolve('成功')
      reject('失败')
  }).then((res)=>{
      console.log(res);
  },(err)=>{
      console.error(err)
  })
  ```

- 加入异步代码测试. 一秒之后无输出. 首先执行器是一个同步代码最先被执行,然后执行then函数,由于状态还是pending,所以无任何输出,一秒之后状态被改变但是then已经执行了.

  ```
  new MyPromise((resolve,reject)=>{
      setTimeout(()=>{
          resolve('成功');
      },1000)
  }).then((res)=>{
      console.log(res);
  },(err)=>{
      console.error(err);
  })
  ```

- 6.在promise类中加入异步代码,实现上述条件

  ```
  const PENDING = 'pending';      //等待
  const FULFILLED = 'fulfilled';  //成功
  const REJECTED = 'rejected';    //失败
  class MyPromise {
      constructor (executor) {   
          executor(this.resolve,this.reject);
      }
      
      status = PENDING;
      value = undefined;
      errInfo = undefined;     
      successCallback = undefined;
      failCallback = undefined;
      resolve = (value) => {
          if(this.status !== PENDING) return;
          this.status = FULFILLED;
          this.value = value;
          //判断成功回调是否是异步执行
          this.successCallback && this.successCallback(value);
      }
  
      reject = (errInfo) => {
          if(this.status !== PENDING) return;
          this.status = REJECTED;
          this.errInfo = errInfo;
          //判断失败回调是否是异步执行
          this.failCallback && this.failCallback(errInfo);        
      }
      
      then (successCallback,failCallback) {
          if(this.status === FULFILLED) successCallback(this.value);
          if(this.status === REJECTED) failCallback(this.errInfo);
          if(this.status === PENDING) {
          		//在then中加入异步逻辑
              this.successCallback = successCallback;
              this.failCallback = failCallback;
          }
      }
  }
  ```

- 但如果是多次调用呢,如下

  ```
  promise.then((res)=>{
      console.log(res);
  },(err)=>{
      console.error(err);
  })
  
  promise.then((res)=>{
      console.log(res);
  },(err)=>{
      console.error(err);
  })
  
  promise.then((res)=>{
      console.log(res);
  },(err)=>{
      console.error(err);
  })
  ```

- 7.实现then方法多次调用

  ```
  const PENDING = 'pending';      //等待
  const FULFILLED = 'fulfilled';  //成功
  const REJECTED = 'rejected';    //失败
  
  class MyPromise {
      constructor (executor) {   
          executor(this.resolve,this.reject);
      }
      status = PENDING;
      value = undefined;
      errInfo = undefined;     
      //成功回调
      successCallback = [];
      //失败回调
      failCallback = [];
      resolve = (value) => {
          if(this.status !== PENDING) return;
          this.status = FULFILLED;
          this.value = value;
          //判断成功回调是否是异步执行
          while(this.successCallback.length) this.successCallback.shift()(value);
      }
  
      reject = (errInfo) => {
          //一旦状态确认就不可更改
          if(this.status !== PENDING) return;
          //将状态更改为失败
          this.status = REJECTED;
          //保存失败之后的值
          this.errInfo = errInfo;
          //判断失败回调是否是异步执行
          while(this.failCallback.length)this.failCallback.shift()(errInfo);
      }
      
      then (successCallback,failCallback) {
          if(this.status === FULFILLED) successCallback(this.value);
          if(this.status === REJECTED) failCallback(this.errInfo);
          if(this.status === PENDING) {
              this.successCallback.push(successCallback);
              this.failCallback.push(failCallback);
          }
      }
  }
  ```

- 8.then方法实现同步链式调用

  >如下,最后需要打印 '成功'和100. 

  

  ```
  let promise = new MyPromise((resolve,reject)=>{
      resolve('成功');
  }).then((res)=>{
      console.log(res);
      return 100
  }).then((res)=>{
      console.log(res);
  })
  ```

  >这里主要修改then中的代码,then中要返回一个新的promise对象,而且每次接收的参数要是上次一返回的值,其实then中的第一个参数就是successCallback,要得到它的返回值调用一下它即可.

  

  ```
      then (successCallback,failCallback) {
          return new MyPromise((resolve,reject)=>{
              if(this.status === FULFILLED) {
                  const x = successCallback(this.value);
                  resolve(x);
              }
          })
      }
  ```



- 9.then方法实现返回promise时的链式调用

  >如下,最后应该要打印 '成功'和'other'

  

  ```
  function other () {
      return new MyPromise((resolve,reject)=>{
          resolve('other');
      })
  }
  let promise = new MyPromise((resolve,reject)=>{
      resolve('成功');
  }).then((res)=>{
      console.log(res);
      return other()
  }).then((res)=>{
      console.log(res);
  })
  ```

  >这里的x不确定是一个值还是一个promise对象. 需要对他进行判断,如果是promise则需要对它返回的值进行判断,同样成功调用resolve,失败调用reject

- 

  ```
  then (successCallback,failCallback) {
          //8.实现链式调用,每次都返回一个新的实例
          return new MyPromise((resolve,reject)=>{
              if(this.status === FULFILLED) {
                  const x = successCallback(this.value);
                  resolvePromise(x,resolve,reject);
                  //resolve(x);
              }
              if(this.status === REJECTED) failCallback(this.errInfo);
              if(this.status === PENDING) {
                  //6.在promise中加入异步代码
                  this.successCallback.push(successCallback);
                  this.failCallback.push(failCallback);
              }
          })
  }
  ```

  ```
  function resolvePromise (x,resolve,reject) {
      //如何判断x是不是prmise 就判断它是不是MyPromise的实例
      if(x instanceof MyPromise){
          //是promise就需要调用then去查看它对应的状态,成功的调用resolve传递下去,失败调用reject
          x.then(value=>resolve(value),errInfo=>reject(errInfo))
      }else{
          resolve(x);
      }
  }
  ```

- 
- 